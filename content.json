{"pages":[{"title":"About","text":"","link":"/About/index.html"}],"posts":[{"title":"Entis","text":"Entis is a C based graphics engine. This is a very low level library for graphics rendering, providing interfaces for basic graphics primatives, text rendering using True Type fonts, and some very minimal image saving and rendering with PNG images. LibraryThe library has one compleated interface, and two more interfaces under development. These interfaces are described below. StandardThe standard interface is to simply include the header file and the core library, then write the code using the base Entis functions. This is the most powerful interface, as it gives the closest connection to the underlying modules that are providing the rendering of the graphics, and the event interfaces. However, it is also significantly more complecated than the other interfaces. Everything must be explicitly done by the user and all event calls have to be controled. FPTThis interface is a simplification and renaming of the core interface. Some methods are removed, and combined with other methods. This is done to simplify the system, and reduce the more technical functions that are required for a basic program to function. This interface is very simple and easy to use. Loop-BasedThis interface is very different from the other interfaces. Instead of the user writing the main function, it is already included in the library. The user has the ability to write a specific set of functions that will be called by the main function if they exists. void setup() This is called after the modules have been initialized, but before any other user code. void draw() This is called every frame void destroy() This is called at the termination of the program, but before the termination of the modules. void onKeyPress() This is called every time a key has been released. void onButtonPress() This is called every time a mouse button has been released. This interface automaticaly constructs, renders, and terminates the core window. It also handles all user interface calls, all the data from the user interface will be saved into globaly available variables, such as mouseX and mouseY. These can be accessed by any user function, allowing users to do as they wish with the data. ModulesThere are several core modules of the Entis graphics engine that are described below. Frame BufferThe entis library stores an internal framebuffer, which all graphics calls are rendered to. This internal framebuffer can be saved to a PNG image, or loaded from some PNG image. XCBEntis implements and controls an XCB connection to the X server. Thus it can handle all XCB connection info, such as input and rendering. If this module is initialized, then all rendering calls are also made to the XCB connection, inorder to display them to the user window. InputUser input can be enabled if the XCB module is initialized. The event system provides multiple interface options inorder to be able to wait or poll for events. The events that are enabled are; mouse_press mouse_release mouse_motion enter_window leave_window key_press key_release window_resize All of these event types are accessable by the user, and any internal information about the event is parsed and inserted into the event class that is returned. PlannedAs the XCB connection is only valid on Linux based system (And is being droped for wayland), work is being done to implement different low level graphics interfaces for Wayland on linux and OSX and Windows operating systems. This will allow implementation of the Entis library on most modern operating systems.","link":"/2019/01/02/Entis/"},{"title":"Dixi","text":"Dixi is an open source, lightweight instant messaging server and client system. BackEndThe backend of Dixi is powered by an express server, with a mongodb for user, and channel data. By default any channel that have been inactive for more than 30 days will have a messages announcing the deletion, and then will be deleted after 24 hours. Only messages from the past two weeks are sent to the client in order to improve speed, but more messages can be requested. FrontEndThe frontend of Dixi has been primarily constructed for terminal usage, but a web client is currently in progress. All messages are rendered using markdown rendering, allowing for significantly improved usability of the messaging system. CLIThe command line interface is the most direct way to interface with Dixi. It allows for creating of channels, and users. It also implements a terminal based markdown renderer, including proper code highlighting. This interface also provides admin tools, such as system posts, and posts to all channels. These tools are only available through this interface. The cli also provides a listener method, which creates a class that listens for any new posts to active channels, and will alert the user of there is a new post. TUIThe terminal user interface is a semi-graphical interface, using unicode characters to create a display completely within the terminal. This interface has all of the tools of the cli with the exception of the admin tools. This interface automatically watches for new posts, and updates the displayed channels accordingly.","link":"/2018/05/15/Dixi/"},{"title":"Lexici","text":"Lexici is a collection of problems implemented in a variety of different languages. The problems are sourced form Project Euler. Using this data set of programming languages constructed using the same algorithm for the same problems allows for interesting comparisons between the different languages. This can be used as a reference to compare implementation of the same algorithm across a number of different programming languages, allowing for better understanding of a new language. Using the timed results of the executable, and the bytes of code required to achieve equivalent algorithms, we assign an efficiency metric. This is a rough approximation of the lines of code required related to the execution speed of that language. It is note worthy that each language is suitable for different tasks, and thus a language may be extremely well suited for one problem, but may require much more work and time on other problems. This is merely a general comparison of how each language fairs against a variety of problems. ProblemsThe currently implemented problems from project Euler are problems one through ten. LanguagesThe currently implemented languages are the following Ada Bash C C++ C# Fortan F# Go JavaScript Lisp Lua Perl Python R Ruby Rust","link":"/2018/09/19/Lexici/"},{"title":"Estl","text":"ESTL is a set of header files that can be used to add advanced utilities to C++ code. The header files each implement a new utility that can be included into any project. There are several available implemented header files that are described below ArgParse1#include&lt;estl/argparse.hpp&gt; This file is an implementation of a highly extendable argument parsing system. The implemented syntax is similar to that of Pythons argparse module. The base class will generate help displays that list all possible arguments. There is currently support for arguments that set flags, or assigning variables of most base types (bool, char, int, double, string, or a list of any of those). Basic1#include&lt;estl/basic/basic.hpp&gt; The basic sub folder implements a minimized alternatives to some of the larger classes. Including Matrix, Vector, and Format. Since each of these are fairly complex, this basic implementation removes much of the extend ability, but provides a much larger boost in speed, and simplicity. Format1#include&lt;estl/format.hpp&gt; This file implements a python like string formatting engine, allowing for the use of printf like utility without requiring character buffers. This also extends that utility, by allowing the use of overloaded operators. By passing a custom class or struct the format of that object will first be attempted by calling a member function of that object called format, if that fills, then it will attempt to use printf type formatting, and finally that system will resort to using ostream formatting. Through this method, any object or type can be cleanly formatted, and provide a string containing the formatted text. Fuzz1#include&lt;estl/fuzz.hpp&gt; The fuzz file implements an efficient string based fuzzy finder. Utilizing either Manhattan distance or Levenshtein distance calculations, the system determines the closest n matches to the input string in a vector of strings. It then returns that array sorted in order of closeness distance. Json1#include&lt;estl/json.hpp&gt; The json file implements reading/writing of .json files from C++, as well as easy manipulation of the json objects, and pretty printing. Note A major rewrite of this module is in development. Logger1#include&lt;estl/logger.hpp&gt; The logging system implemented allows for extreme control over a easy to use logging system. The general format for a logger can be specified, then each call to a logger uses printf formatting. The collection of call functions utilize macros to determine the source file, function name, and line number that the log message was called from, allowing significantly improved diagnoses of logged messages. There are five different logger bases, then the default logger can consist of any collection of these. ConsoleLogger FileLogger DailyLogger CounterLogger StreamLogger More detail can be found in the documentation. Matrix1#include&lt;estl/matrix.hpp&gt; The matrix file is primarily to provide a mathematical matrix object. Using templated arguments, the matrix class provides all common mathematical matrix operations, utilizing the templated types commands. Note that sparse matrix optimizations have not been implemented. Stream1#include&lt;estl/stream.hpp&gt; The stream file is to provide an extended implementation of printf that utilizes C++ streams. This is a smaller version of the format file. This again implements the use of stream operators, but does not utilize the more advanced features that are available in the format file. Tree1#include&lt;estl/tree.hpp&gt; The tree class implements an arbitrary tree data structure. It provides easy ways to add or remove children. There are three different iterators that can be used for traversing the tree: depth_iterator sibling_iterator leaf_iterator The class also provides methods for printing the tree. Variable1#include&lt;estl/variable.hpp&gt; This file provides a general variable which is represented as a union of most fundamental C++ types, as well as vectors of those types, including bool char signed char unsigned char signed short int unsigned short int signed int unsigned int signed long int unsigned long int signed long long int unsigned long long int float double long double std::string const char* Variadic1#include&lt;estl/variadic.hpp&gt; The variadic files implements utility functions for handling variadic packed template arguments. It provides methods for unpacking arguments into vector, tuple, and vector&lt;any&gt;, allowing simple access of packed arguments. Vector1#include&lt;estl/vector.hpp&gt; The vector file is a mathematical vector object. Using templated arguments, the vector class provides most common mathematical vector operations, utilizing the templated types commands.","link":"/2018/09/12/Estl/"},{"title":"Ray Tracer","text":"This ray tracer implements the basis of a ray tracing rendering engine in C++. It is possible to render still images, or sequences of images. Multi threading has also been implemented allowing for significantly faster render times. The ability to create multiple object of sphere, triangle, plane, circle, or mesh types is currently available. Where a mesh is any collection of triangles specified by an *.stl file. Thus allowing for the import of any arbitrary model. Using these five different supported objects, there is the possibility for the construction of all three dimensional models. The implementation of different materials is such that the reflectively of the material, the specular index, and the diffuse and specular colors can be determined. Using these settings it is possible to demonstrate most opaque materials. There are three formats of lights implemented in the system. Distant lights are lights that cast parallel rays across the entire space. They are useful for simulations of sunlight, or large sources of light that are very far away. Point lights approximate point sources. Area lights represent a light source from a rectangle. This is useful for most light sources, as very few sources of light are actual point sources, and can be better represented by this area light source. Every light can have have a specified intensity and color. And area light sources can specify the number of samples for calculating the lighting. Higher number of samples improves the quality of soft shadows produced in the final image. The entire process is self enclosed, as the process of compilation also compiles and links libpng in order to output png files. The multi threading is optimized by scattering the pixels that each thread renders, so that no single thread is solely rendering a simple set of pixels. This proves a significantly faster rendering time. Thus allowing for the rendering of significantly more complex systems.","link":"/2018/04/29/Ray-Tracer/"},{"title":"Loc","text":"Loc is a simple python program used for counting the number of lines of code in a project. It prints a table distribution of the lines/bytes for each recognized language in the project. The program quickly scans all the files in a directory, and if the flag -r is set then it does so recursively. If the --git flag is set, then all files that are in the .gitignore file will be removed from the count. Then every file type is determined. This is done primarily through file extension, then it attempts at read a shebang to determine the file type. Using the files types it reads through each file, keeping track of the lines of code, and the lines of comments, and it ignores the blank lines. Finally it displays a table of the acquired data, and a bar graph representing the percentages that each language represents in the project. Currently there is support for 42 different languages. Ada CoffeeScript J Perl Text AsciiDoc Common Lisp JSON Python TypeScript Assembly Cuda Java R VimScript Bash D JavaScript Ruby Web Assembly Brainfuck Diff LLVM Rust YAML C E Less SQL Zsh C# Emacs Lisp Lex SVG reStructuredText C++ F# Lua Sage CMake Fish M Sass COBOL Fortran Makefile Scala CSS GLSL Markdown Shell CSV Go Objective-C Swift Clojure HTML OpenCL TeX","link":"/2018/06/21/Loc/"}],"tags":[{"name":"C","slug":"C","link":"/tags/C/"},{"name":"Javascript","slug":"Javascript","link":"/tags/Javascript/"},{"name":"Python","slug":"Python","link":"/tags/Python/"},{"name":"Cpp","slug":"Cpp","link":"/tags/Cpp/"},{"name":"Ada","slug":"Ada","link":"/tags/Ada/"},{"name":"Fortran","slug":"Fortran","link":"/tags/Fortran/"},{"name":"Lisp","slug":"Lisp","link":"/tags/Lisp/"},{"name":"Rust","slug":"Rust","link":"/tags/Rust/"},{"name":"Go","slug":"Go","link":"/tags/Go/"},{"name":"Csharp","slug":"Csharp","link":"/tags/Csharp/"},{"name":"Lua","slug":"Lua","link":"/tags/Lua/"},{"name":"Fsharp","slug":"Fsharp","link":"/tags/Fsharp/"},{"name":"R","slug":"R","link":"/tags/R/"},{"name":"Shell","slug":"Shell","link":"/tags/Shell/"},{"name":"Perl","slug":"Perl","link":"/tags/Perl/"},{"name":"Ruby","slug":"Ruby","link":"/tags/Ruby/"}],"categories":[{"name":"CS","slug":"CS","link":"/categories/CS/"},{"name":"Graphics","slug":"CS/Graphics","link":"/categories/CS/Graphics/"},{"name":"Web","slug":"CS/Web","link":"/categories/CS/Web/"}]}